#  create-iso.yml
#  Created: 2024/09/15 - 08:10
#  Altered: qui 19 fev 2026 21:40:30 -04
#
#  Copyright (c) 2024-2026, Vilmar Catafesta <vcatafesta@gmail.com>
#  All rights reserved.
#
#  Redistribution and use in source and binary forms, with or without
#  modification, are permitted provided that the following conditions
#  are met:
#  1. Redistributions of source code must retain the above copyright
#     notice, this list of conditions and the following disclaimer.
#  2. Redistributions in binary form must reproduce the above copyright
#     notice, this list of conditions and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#
#  THIS SOFTWARE IS PROVIDED BY THE AUTHOR AS IS'' AND ANY EXPRESS OR
#  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
#  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
#  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
#  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
#  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
#  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
#  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
#  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
#  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
##############################################################################
name: üíø Build ISO VoidBR

concurrency:
  group: build-iso-${{ github.workflow }}
  cancel-in-progress: false

# Gatilhos para o workflow
on:
  #push:
  #  branches:
  #    - main
  repository_dispatch: # aguarda um evento externo para iniciar o workflow (√∫til para automa√ß√µes externas que acionam o GitHub Actions).
    types:
      - "ISO-*"
  workflow_dispatch:
    inputs:
      teste_input:
        type: boolean
        description: "Enable only test"
        required: false
        default: false
      edition:
        type: choice
        description: "Edition"
        options:
          - teste
          - base
          - awesome
          - cinnamon
          - enlightenment
          - fluxbox
          - gnome
          - plasma
          - xfce
          - mate
          - fullx
          - all
        default: "base"
      vol_id:
        type: string
        description: "Nome do VOLUME da ISO"
        required: true
        default: "VOIDBR_LIVE"
      tmate:
        type: boolean
        description: "Enable debugging with tmate"
        required: false
        default: false
      release_tag:
        type: string
        description: "Release tag for the ISO"
        required: false

  schedule:
    #- cron: "0 6 * * *" # Roda todo dia √†s 06:00 UTC
    - cron: "0 18 * * 5" # Roda toda sexta-feira √†s 18:00 UTC

env:
  TELEGRAM_TOKEN: "${{ secrets.TOKEN_BOT }}"
  TELEGRAM_VOIDBR_ISO_TOKEN_BOT: "${{ secrets.VOIDBR_ISO_TOKEN_BOT }}"
  #GITHUB_TOKEN: "${{ secrets.TOKEN_RELEASE }}"
  #GITHUB_TOKEN: "${{ secrets.GITHUB_TOKEN }}"
  GITHUB_TOKEN: "${{ secrets.ORGANIZATION_TOKEN }}"
  CHAT_ID: "${{ secrets.CHAT_ID }}"
  MESSAGE_THREAD_ID: "${{ secrets.MESSAGE_THREAD_ID }}"
  started_by_user: "${{ github.actor }}"
  triggered_by_user: "${{ github.triggering_actor }}"
  repo_path: "${{ secrets.PKGBUILD_DIR }}"
  iso_distroname: "${{ github.event.client_payload.distroname || inputs.distroname || 'voidbr' }}"
  iso_profile: "${{ github.event.client_payload.iso_profiles_repo || inputs.iso_profiles_repo || 'profile' }}"
  #iso_manjaro_branch: "${{ github.event.client_payload.manjaro_branch || inputs.manjaro_branch}}"
  #iso_biglinux_branch: "${{ github.event.client_payload.biglinux_branch || inputs.biglinux_branch}}"
  #iso_bigcommunity_branch: "${{ github.event.client_payload.community_branch || inputs.community_branch}}"
  #iso_chililinux_branch: "${{ github.event.client_payload.chililinux_branch || inputs.chililinux_branch}}"
  #iso_build_dir: "${{ github.event.client_payload.build_dir || inputs.build_dir}}"
  #iso_kernel: "${{ github.event.client_payload.kernel || inputs.kernel }}"
  iso_edition: "${{ github.event.client_payload.edition || inputs.edition || 'base' }}"
  release_tag: "${{ github.event.client_payload.release_tag || inputs.release_tag || '20261111-1111' }}"
  iso_basename: "voidbr-live-${{ github.event.client_payload.edition || inputs.edition }}-x86_64-x86_64-6.12.74_1_${{ github.event.client_payload.release_tag || inputs.release_tag || '20261111-1111' }}"
  vol_id: "${{ github.event.client_payload.vol_id || inputs.vol_id }}"
  DEBUG: "${{ github.event.client_payload.tmate || inputs.tmate || false }}"
  tmate: "${{ github.event.client_payload.tmate || inputs.tmate || false }}"

jobs:
  setup:
    runs-on: ubuntu-latest
    outputs:
      time: ${{ steps.time.outputs.time }} # Sa√≠da do job
      REPOSITORY_NAME: ${{ steps.get-repo-name.outputs.repo_name }}
    steps:
      - name: Obter a hora atual
        id: time
        shell: bash
        run: |
          #Obter a hora atual
          #echo "::set-output name=time::$(date +'%Y.%m.%d-%H%M')"
          echo "time=$(date +'%Y.%m.%d-%H%M')" >> $GITHUB_OUTPUT

      - name: Capturar hora de in√≠cio do workflow
        id: start-time
        shell: bash
        run: |
          START_TIME=$(date +"%Y-%m-%d %H:%M:%S")  # Hora completa
          START_TIMESTAMP=$(date +%s)  # Timestamp em segundos
          echo "In√≠cio do Workflow: $START_TIME"
          echo "START_TIME=$START_TIME"             >> $GITHUB_ENV
          echo "START_TIMESTAMP=$START_TIMESTAMP"   >> $GITHUB_ENV
          echo "START_TIME='$START_TIME'"           >> shared_file.txt
          echo "START_TIMESTAMP='$START_TIMESTAMP'" >> shared_file.txt

      - name: Create Global Helpers Script - Definir a fun√ß√£o send_telegram_message no script tempor√°rio
        shell: bash
        env:
          TELEGRAM_TOKEN: "${{ inputs.telegram_token }}"
          TELEGRAM_VOIDBR_ISO_TOKEN_BOT: "${{ inputs.voidbr_iso_token_bot }}"
          TELEGRAM_CHAT_ID: "${{ inputs.telegram_chat_id }}"
          TELEGRAM_MESSAGE_THREAD_ID: "${{ inputs.telegram_message_thread_id }}"
        run: |
          #Definir a fun√ß√£o send_telegram_message no script tempor√°rio
          sudo rm -rf /tmp/send_telegram_message.sh  # Remove se for diret√≥rio
          cat << 'EOF' > /tmp/send_telegram_message.sh
          export TERM=${TERM:-xterm}
          export TERM=${TERM:-xterm-256color}

          #Definindo vari√°veis de cores
          export reset="\033[0m"
          export rst="\033[0m"
          export green="\033[01;32m"
          export red="\033[01;31m"
          export blue="\033[01;34m"
          export cyan="\033[01;36m"
          export pink="\033[01;35m"
          export yellow="\033[01;33m"
          alias ls='ls -lha --color=auto'
          alias dir='ls -lha --color=auto'

          die() {
            local msg="$1"
            msg="$(sed 's/<[^>]*>//g' <<< "$msg")" # Remove as tags HTML
            echo -e "BP=>${cyan}error: ${red}${msg}${reset}"
            exit  1
          }
          export -f die

          msg() {
            local msg="$1"
            msg="$(sed 's/<[^>]*>//g' <<< "$msg")" # Remove as tags HTML
            echo -e "BIV=>${cyan}running: ${yellow}${msg}${reset}"
          }

          msg_tab() {
            local msg="$1"
            msg="$(sed 's/<[^>]*>//g' <<< "$msg")" # Remove as tags HTML
            echo -e "BIV=>${yellow}info   : ${cyan}${msg}${reset}"
          }

          msg_raw() {
            local msg="$1"
            # Remove tags HTML, se existirem
            #msg="$(sed 's/<[^>]*>//g' <<< "$msg")"

            # Verifica se existe ':' na mensagem
            if [[ "$msg" == *:* ]]; then
              # Divide a string antes e depois do primeiro ':'
              local before_colon="${msg%%:*}:"
              local after_colon="${msg#*: }"
              # Aplica as cores
              msg="${cyan}${before_colon} ${yellow}${after_colon}${reset}"
            else
              # Se n√£o houver ':', aplica apenas a cor padr√£o
              msg="${cyan}${msg}${reset}"
            fi
            echo -e "$msg"
          }
          export -f msg_raw

          msg_ok() {
            local msg="$1"
            msg="$(sed 's/<[^>]*>//g' <<< "$msg")" # Remove as tags HTML
            echo -e "BP=>${cyan}feito  : ${green}${msg}${reset}"
          }
          export -f msg_ok

          msg_run() {
            local msg="$1"
            echo -e "BP=>${cyan}running: ${yellow}${msg}${reset}"

            # Executa o comando e captura o c√≥digo de sa√≠da
            if ! eval "$msg"; then
              echo -e "BP=>${red}Erro ao executar: ${yellow}${msg}${reset}" >&2
              return 1
            fi
            return 0
          }
          export -f msg_run

          msg_info() {
            local msg="$1"
            msg="$(sed 's/<[^>]*>//g' <<< "$msg")" # Remove as tags HTML
            echo -e "BIV=>${yellow}info   : ${cyan}${msg}${reset}"
          }

          msg_warning() {
            local msg="$1"
            msg="$(sed 's/<[^>]*>//g' <<< "$msg")" # Remove as tags HTML
            echo -e "BIV=>${red}warning: ${orange}${msg}${reset}"
          }

          replicate() {
            local char=${1:-'#'}
            local nsize=${2:-$(tput cols)}
            local line
            #printf -v line "%*s" "$nsize" && echo "${line// /$char}"
            #printf -v line "%*s" "$nsize" && echo -e "\033[31m${line// /$char}\033[0m"
            printf -v line "%*s" "$nsize" && echo -e "${blue}${line// /$char}${reset}"
          }
          export -f replicate

          function send_telegram_message() {
            local message="$1"
            local parse_mode="$2"

            # Define parse_mode como "MarkdownV2" se n√£o for especificado
            [[ -z $parse_mode ]] && parse_mode="HTML"

            link_action=https://github.com/${GITHUB_REPOSITORY}/actions/runs/${GITHUB_RUN_ID}

            MESSAGE="üöÄ <b>${{ github.workflow }}</b>
            <pre>
            Job         : #${GITHUB_RUN_NUMBER}
            Workflow    : ${{ github.workflow }}
            Triggered   : ${started_by_user}
            Inicio      : ${{ env.START_TIME }}
            Distroname  : ${iso_distroname}
            Edition     : ${iso_edition}
            Kernel      : ${{ env.KERNEL_VERSION }}
            Release     : ${release_tag}
            Tmate       : ${{ env.DEBUG }}
            ISO Name    : voidbr-live-${iso_edition}-x86_64
            </pre>
            <b>Link:</b> <a href='${link_action}'>Visualizar no GitHub</a>"

            MESSAGE="${{ github.workflow }} - $message
            <b>Job         :</b> <code>#${GITHUB_RUN_NUMBER}</code>
            <b>Job URL     :</b> <a href='https://github.com/${GITHUB_REPOSITORY}/actions/runs/${GITHUB_RUN_ID}'>${link_action}</a>
            <b>Workflow    :</b> <code>${{ github.workflow }}</code>
            <b>Triggered   :</b> <code>${started_by_user}/${triggered_by_user}</code>
            <b>Inicio      :</b> <code>${{ env.START_TIME }}</code>
            <b>Distroname  :</b> <code>${iso_distroname}</code>
            <b>Iso Profile :</b> <code>${iso_profile}</code>
            <b>Edition     :</b> <code>${iso_edition}</code>
            <b>Build dir   :</b> <code>${iso_build_dir}</code>
            <b>Release     :</b> <code>${release_tag}</code>
            <b>Kernel      :</b> <code>${{ env.KERNEL_VERSION }}</code>
            <b>Tmate       :</b> <code>${{ env.DEBUG }}</code>
            <b>ISO Name    :</b> <code>voidbr-live-${iso_edition}-x86_64_${release_tag}</code>
            <b>Fim      :</b> <code>${END_TIME}</code>
            <b>Nome ISO :</b> <code>${{env.iso_basename}}</code>
            <b>Tam ISO  :</b> <code>${iso_size}</code>
            <b>Download :</b> <a href='${{ env.artifact_url }}'>${file_name}.zip</a>"

            # Remove as tags HTML e exibe o resultado no terminal
            echo -e "${green}$(sed 's/<[^>]*>//g' <<< "$MESSAGE")${reset}"
            # Envia a mensagem original com HTML para o Telegram
            curl -s -X POST "https://api.telegram.org/bot${TELEGRAM_VOIDBR_ISO_TOKEN_BOT}/sendMessage" \
              -d chat_id="${CHAT_ID}" \
              -d message_thread_id="${MESSAGE_THREAD_ID}" \
              -d text="${MESSAGE}" \
              -d parse_mode="HTML"
          }
          export -f send_telegram_message
          EOF
          chmod +x /tmp/send_telegram_message.sh

      - name: Install dependencies in HOST
        shell: bash
        run: |
          #Install dependencies in HOST
          #sudo apt-get update
          #sudo apt-get autoremove
          #sudo apt-get install -y inetutils-tools duf tree tmate
          sudo apt-get install -y inetutils-tools duf tree

      #      - name: Setup TMATE Session in HOST
      #        uses: mxschmitt/action-tmate@v3
      #        with:
      #          install-dependencies: false
      #          detached: true

      - name: Set up volume directory in HOST
        shell: bash
        run: |
          #Set up volume directory in HOST
          sudo mkdir -p /mnt/var_lib_manjaro_tools_buildiso
          sudo mkdir -p /mnt/var_cache_manjaro_tools_iso
          sudo mkdir -p /mnt/lfs

      - name: Enviar notifica√ß√£o inicial para o Telegram
        shell: bash
        run: |
          source /tmp/send_telegram_message.sh
          replicate
          msg "- name: Enviar notifica√ß√£o inicial para o Telegram"

          msg_tab "ISO_BRANCH='$iso_branch'"
          msg_tab "ISO_BRANCH='$iso_branch'"
          echo "ISO_BRANCH='$iso_branch'" >> GITHUB_ENV
          echo "ISO_BRANCH='$iso_branch'" >> shared_file.txt

          #link_action=https://github.com/${GITHUB_REPOSITORY}/actions/runs/${GITHUB_RUN_ID}
          #MESSAGE="üöÄ <b>[step 1/3] - Iniciando WorkFlow ${{ github.workflow }}</b>
          #<b>Job:</b> <code>#${GITHUB_RUN_NUMBER}</code>
          #<b>Job URL:</b> <a href='https://github.com/${GITHUB_REPOSITORY}/actions/runs/${GITHUB_RUN_ID}'>${link_action}</a>
          #<b>Workflow:</b> <code>${{ github.workflow }}</code>
          #<b>Iniciado/Triggered:</b> <code>${started_by_user}/${triggered_by_user}</code>
          #<b>Inicio:</b> <code>${{ env.START_TIME }}</code>
          #<b>Distroname:</b> <code>${iso_distroname}</code>
          #<b>Iso Profile:</b> <code>${{ github.event.client_payload.iso_profiles_repo || inputs.iso_profiles_repo }}</code>
          #<b>Edition:</b> <code>${iso_edition}</code>
          #<b>Build dir:</b> <code>${iso_build_dir}</code>
          #<b>Release:</b> <code>${release_tag}</code>
          #<b>Kernel:</b> <code>${iso_kernel}</code>
          #<b>Tmate:</b> <code>${{ env.DEBUG }}</code>
          #<b>ISO Name:</b> <code>voidbr-live-${iso_edition}-x86_64_${release_tag}</code>"

          ## Remove as tags HTML e exibe o resultado no terminal
          #echo -e "${green}$(sed 's/<[^>]*>//g' <<< "$MESSAGE")${reset}"
          ## Envia a mensagem original com HTML para o Telegram
          #curl -s -X POST "https://api.telegram.org/bot${TELEGRAM_VOIDBR_ISO_TOKEN_BOT}/sendMessage" \
          #  -d chat_id="${CHAT_ID}" \
          #  -d message_thread_id="${MESSAGE_THREAD_ID}" \
          #  -d text="${MESSAGE}" \
          #  -d parse_mode="HTML"

          MESSAGE="üöÄ <b>[step 1/3] - Iniciando WorkFlow</b>"
          send_telegram_message "$MESSAGE"
          replicate

      #      - name: Cria um arquivo de variaveis para compartilhar entre jobs
      #        shell: bash
      #        run: |
      #          #Cria um arquivo de variaveis para compartilhar entre jobs
      #          echo "START_TIME='$START_TIME'"           >> shared_file.txt
      #          echo "START_TIMESTAMP='$START_TIMESTAMP'" >> shared_file.txt
      #          echo "ISO_BRANCH='$iso_branch'"           >> shared_file.txt

      - name: Obter nome do reposit√≥rio
        id: get-repo-name
        shell: bash
        run: |
          source /tmp/send_telegram_message.sh
          replicate
          msg "- name: Obter nome do reposit√≥rio"
          msg_tab "repo_name=$(basename $GITHUB_REPOSITORY)"
          echo "repo_name=$(basename $GITHUB_REPOSITORY)" >> $GITHUB_OUTPUT
          replicate

      - name: Upload script as artifact
        uses: actions/upload-artifact@v4
        with:
          name: telegram-script
          path: /tmp/send_telegram_message.sh

      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: shared-file
          path: shared_file.txt

      - name: Display the current user in HOST
        shell: bash
        run: |
          source /tmp/send_telegram_message.sh
          replicate
          msg "- name: Display the current user in HOST"
          echo "#########################################"
          echo "Current host is: $(hostname)"
          echo "Current user is: $(whoami)"
          echo "Current user ID is: $(id -u)"
          echo "Current user details:"
          id
          echo "#########################################"
          #df -hT
          duf
          echo "#########################################"
          ls
          echo "#########################################"
          replicate

  build:
    #name: Build ISO ${{ github.event.client_payload.edition || inputs.edition || 'base' }}
    name: Build ISO ${{ matrix.edition }}
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        edition: ${{ (inputs.edition || 'base') == 'all' && fromJson('["base","fullx","xfce","mate","gnome","plasma","fluxbox","awesome","cinnamon","enlightenment"]') || fromJson(format('["{0}"]', inputs.edition || 'base')) }}
    needs: [setup] # Espera o job "setup" terminar
    env:
      #REPO_NAME: ${{ needs.set-repo-name.outputs.REPOSITORY_NAME }} # Acesso √† vari√°vel de ambiente definida no job anterior
      REPO_NAME: "${{ github.repository }}"
      iso_edition: ${{ matrix.edition }}
    container:
      #image: vcatafesta/voidlinux-docker:latest
      #image: vcatafesta/voidlinux-docker:1.1
      #image: vcatafesta/voidlinux-docker:1.2 #ter 17 dez 2024 21:48:17 -04
      #image: vcatafesta/voidlinux-docker:1.4
      image: vcatafesta/voidlinux-docker:1.5 #seg 16 fev 2026 23:52:08 -04
      options: --privileged
      volumes:
        - /mnt/var_lib_manjaro_tools_buildiso:/var/lib/manjaro-tools/buildiso
        - /mnt/var_cache_manjaro_tools_iso:/var/cache/manjaro-tools/iso
        - /mnt/lfs:/mnt/lfs

    steps:
      - name: Download Telegram Script
        uses: actions/download-artifact@v4
        with:
          name: telegram-script
          path: /tmp/ # O download-artifact vai colocar o arquivo em /tmp/send_telegram_message.sh dentro do container

      - name: Download artifact shared-file
        uses: actions/download-artifact@v4
        with:
          name: shared-file

      - name: Exibir e carregar vari√°veis do arquivo shared_file.txt no CONTAINER
        shell: bash
        run: |
          source /tmp/send_telegram_message.sh
          replicate
          msg "- name: Exibir e carregar vari√°veis do arquivo shared_file.txt no CONTAINER"
          cat shared_file.txt
          # Atribuir o conte√∫do do arquivo √† vari√°vel START_TIME
          #START_TIME="$(<shared_file.txt)"
          source shared_file.txt
          # Definir a vari√°vel START_TIME para outros jobs
          msg "START_TIME=$START_TIME"
          msg "START_TIMESTAMP=$START_TIMESTAMP"
          msg "ISO_BRANCH=$ISO_BRANCH"
          echo "START_TIME=$START_TIME"           >> $GITHUB_ENV
          echo "START_TIMESTAMP=$START_TIMESTAMP" >> $GITHUB_ENV
          echo "ISO_BRANCH=$ISO_BRANCH"           >> $GITHUB_ENV
          replicate

      - name: Checkout repository voidbr-build-iso
        uses: actions/checkout@v4
        with:
          #fetch-depth: 0    # All commit history is downloaded
          fetch-depth: 1 # Only the most recent commit of the branch will be downloaded

      - name: Set up volume directory in CONTAINER
        shell: bash
        run: |
          #Set up volume directory in HOST
          mkdir -p /mnt/lfs
          ln -sf /mnt/lfs /lfs

      - name: Install Required Packages and Libraries no CONTAINER
        shell: bash
        run: |
          source /tmp/send_telegram_message.sh
          replicate
          msg "- name: Install Required Packages and Libraries no CONTAINER"
          {
          echo 'repository=https://void.voidbr.org/voidlinux/current'
          echo 'repository=https://void.voidbr.org/voidlinux/extra'
          echo 'repository=https://void.voidbr.org/voidlinux/current/nonfree'
          echo 'repository=https://void.voidbr.org/voidlinux/current/multilib'
          echo 'repository=https://void.voidbr.org/voidlinux/current/multilib/nonfree'
          echo
          echo 'repository=https://void.chililinux.com/voidlinux/current'
          echo
          echo 'repository=https://repo-fastly.voidlinux.org/current'
          echo 'repository=https://repo-fastly.voidlinux.org/current/nonfree'
          echo 'repository=https://repo-fastly.voidlinux.org/current/multilib'
          echo 'repository=https://repo-fastly.voidlinux.org/current/multilib/nonfree'
          echo
          } > /etc/xbps.d/00-repository-main.conf

          xbps-install -Sy
          xbps-install -yu xbps
          xbps-install -yu \
            bash \
            xtools \
            sudo \
            openssh \
            tmate \
            xz \
            zip \
            p7zip \
            jq \
            github-cli \
            kmod \
            ncurses \
            which \
            vpm \
            libstdc++ \
            nano \
            curl \
            git \
            bash \
            tree \
            duf \
            gettext \
            rsync \
            util-linux \
            coreutils \
            sed \
            grep \
            btrfs-progs \
            e2fsprogs \
            exfatprogs \
            dosfstools \
            xfsprogs
          vinstall -Scc
          replicate

      - name: Create user builduser in CONTAINER
        shell: bash
        run: |
          source /tmp/send_telegram_message.sh
          replicate
          msg "- name: Create user builduser in CONTAINER"
          if ! getent passwd builduser >/dev/null; then
            useradd -m -G wheel,audio,video,cdrom,optical,kvm,xbuilder builduser || true
          fi
          id builduser
          replicate

      - name: Initial Debug in CONTAINER
        env:
          EVENT_JSON: ${{ toJson(github.event) }}
        shell: bash
        run: |
          source /tmp/send_telegram_message.sh
          replicate
          msg "- name: Initial Debug in CONTAINER"
          echo "Workflow started"
          echo "Event Name: ${{ github.event_name }}"
          echo "Event Action: ${{ github.event.action }}"
          echo "Edition: ${{ github.event.client_payload.edition || inputs.edition }}"
          echo "Tmate from payload: ${{ github.event.client_payload.tmate || inputs.tmate != false && inputs.tmate }}"
          echo "Full github event:"
          printf '%s\n' "$EVENT_JSON"
          replicate

      - name: Display the current user in CONTAINER
        shell: bash
        run: |
          source /tmp/send_telegram_message.sh
          replicate
          msg "- name: Display the current user in CONTAINER"
          echo "#########################################"
          echo "Current container is: $(hostname)"
          echo "Current user is: $(whoami)"
          echo "Current user ID is: $(id -u)"
          echo "Current user details:"
          id
          echo "#########################################"
          #df -hT
          duf
          echo "#########################################"
          ls -lah --color=auto /mnt
          echo "#########################################"
          tree -d /mnt
          echo "#########################################"
          replicate

      - name: Set release tag manually
        id: date
        shell: bash
        run: |
          # Set release tag manually
          RELEASE_TAG="${release_tag:-$(date '+%Y-%m-%d_%H-%M')}"
          echo "RELEASE_TAG=$RELEASE_TAG" >> "$GITHUB_ENV"

      - name: Build ISO voidbr-live-${{ github.event.client_payload.edition || inputs.edition}}-x86_64_${{ github.event.client_payload.release_tag || inputs.release_tag }}
        if: ${{ inputs.teste_input != true }}
        uses: ./
        id: build
        with:
          vol_id: ${{env.vol_id}}
          #edition: ${{env.iso_edition}}
          edition: ${{ matrix.edition }}
          release_tag: ${{env.RELEASE_TAG}}
          github_token: ${{env.GITHUB_TOKEN}}
          tmate: ${{ env.DEBUG }}
          iso_basename: ${{ env.iso_basename }}

      #ponto de retorno do action.yml
      - name: Set ISO path on create-iso
        shell: bash
        run: |
          source /tmp/send_telegram_message.sh
          replicate
          msg "- name: Set ISO path on create-iso"
          # Localiza a ISO no workspace sem tentar mover o arquivo
          #temporario - para testes
          #WORK_PATH='/__w/build-iso/build-iso'
          #ISO_BASENAME="${iso_distroname}_${ISO_BRANCH^^}_${iso_edition}_${release_tag}.iso"
          #{
          #  echo "WORK_PATH=$WORK_PATH"
          #  echo "ISO_BASENAME=$ISO_BASENAME"
          #} >> $GITHUB_ENV
          #echo "ISO_PATH=${WORK_PATH}/${ISO_BASENAME}" >> $GITHUB_ENV
          #touch "${WORK_PATH}/${ISO_BASENAME}"
          #temporario - para testes
          echo "ISO_PATH=${{ env.WORK_PATH }}/${{ env.ISO_BASENAME }}" >> $GITHUB_ENV

      - name: Verificar se o arquivo .iso foi gerado corretamente
        if: ${{ inputs.teste_input != true }}
        shell: bash
        run: |
          source /tmp/send_telegram_message.sh
          replicate
          msg "- name: Verificar se o arquivo .iso foi gerado corretamente"
          pushd "${{ env.WORK_PATH }}" || true
          msg_info 'ls -lah --color=auto'
          ls -lah --color=auto
          popd || true
          replicate

      - name: Calculate ISO MD5 Hash
        shell: bash
        run: |
          # Calculate ISO MD5 Hash
          source /tmp/send_telegram_message.sh
          replicate '='
          ls -lah --color=auto || true
          replicate '='
          msg "Calculating MD5 hash for ISO file ${ISO_PATH}"

          # Ajuste no pushd para usar o WORK_PATH detectado no step anterior
          pushd "${{ env.WORK_PATH }}" || true

          if [[ -f "${{ env.ISO_BASENAME }}" ]]; then
            md5sum "${{ env.ISO_BASENAME }}" > "${{ env.ISO_BASENAME }}.md5"
            msg_info "MD5 '$ISO_BASENAME.md5' hash calculated and saved:"
            cat "${{ env.ISO_BASENAME }}.md5"
          else
            msg_warning "Error: ${{ env.ISO_BASENAME }} file not found at ${{ env.WORK_PATH }}"
            exit 1
          fi

          ls -lah --color=auto
          replicate '='
          popd || true

      - name: Prepare ISO for release (7z)
        id: prepare-iso
        shell: bash
        run: |
          #Prepare ISO for release (7z)
          source /tmp/send_telegram_message.sh
          replicate
          msg "- name: Prepare ISO for release (7z)"
          MESSAGE="‚è≥ <b>[step 2/3] - Prepare ISO for release (7z)</b>"
          send_telegram_message "$MESSAGE"
          replicate '='
          ls -lah
          release=$(basename "${ISO_PATH}" .iso)
          release_name="${release}"

          # Obt√©m o tamanho do arquivo em bytes
          file_size=$(stat -c%s "${ISO_PATH}")

          # Verifica se o tamanho √© maior que 2000 MB (2000 * 1024 * 1024 bytes)
          if (( file_size > 2000 * 1024 * 1024 )); then
            msg_info "O arquivo √© maior que 2000 MB. Compactando e dividindo..."
            #7z a -v2000m "${release}.7z" "${ISO_PATH}" # Compacta e divide em partes de 2000 MB
            #upload_path="${release}.7z*"
            7z a -v2000m "${ISO_PATH}.7z" "${ISO_PATH}"
            upload_path="${ISO_PATH}.7z*"
          else
            msg_info "O arquivo n√£o √© maior que 2000 MB. N√£o ser√° compactado."
            upload_path="${ISO_PATH}"
          fi

          echo "release=${release}"         >> "$GITHUB_OUTPUT"
          echo "release_name=${release}"    >> "$GITHUB_OUTPUT"
          echo "upload_path=${upload_path}" >> "$GITHUB_OUTPUT"

          msg_info "ISO ${release} prepared for release"
          replicate '='
          ls -lah
          replicate '='
          # Debug
          msg_info "ISO_PATH (original): ${ISO_PATH}"
          msg_info "Upload Path        : ${upload_path}"
          msg_info "ISO_PATH (md5)     : ${ISO_PATH}.md5"
          msg_info "release            : ${release}"
          msg_info "release_name       : ${release_name}"
          replicate '='

      - name: Upload ISO as artifact
        if: ${{ inputs.teste_input != true }}
        uses: actions/upload-artifact@v4
        with:
          #name: Full_ISO_${{ steps.prepare-iso.outputs.release_name }}
          #name: ${{ env.ISO_BASENAME }}
          #name: ${{ steps.prepare-iso.outputs.release_name }}
          name: ${{ steps.prepare-iso.outputs.release_name }}-${{ github.run_id }}
          path: |
            #${{ env.ISO_FULLNAME }}
            ${{ env.ISO_FULLNAME }}.md5
            ${{ steps.prepare-iso.outputs.upload_path }}
            #${{ env.ISO_FULLNAME }}.md5
          if-no-files-found: warn
          include-hidden-files: false

      - name: Create Release
        if: ${{ inputs.teste_input != true }}
        id: create_release
        uses: softprops/action-gh-release@v2
        with:
          files: |
            #${{ env.WORK_PATH }}/${{ steps.prepare-iso.outputs.release }}*
            ${{ steps.prepare-iso.outputs.upload_path }}
            ${{ env.ISO_PATH }}.md5
          #tag_name: ${{ env.ISO_TAG_NAME }}
          tag_name: ${{ env.ISO_TAG_NAME }}-${{ github.run_id }}
          name: ${{ steps.prepare-iso.outputs.release_name }}
          generate_release_notes: true
          body: |
            - **Data e Hora         :** ${{ env.START_TIME }}
            - **Arquivo ISO         :** ${{ env.ISO_BASENAME }}
            - **Arquivo MD5         :** ${{ env.ISO_BASENAME }}.md5
            - **Nome do Reposit√≥rio :** ${{ env.REPO_NAME }}
          draft: false
          prerelease: false
          fail_on_unmatched_files: false

      - name: Get Artifact URL
        id: get-artifact-url
        env:
          GITHUB_TOKEN: "${{ secrets.GITHUB_TOKEN }}"
          #FILE_NAME: "${ISO_BASENAME%.iso}"
          FILE_NAME: "${{ steps.prepare-iso.outputs.release_name }}"
          RUN_ID: "${{ github.run_id }}"
          REPO: "${{ github.repository }}"
        shell: bash
        run: |
          # Get Artifact URL
          artifacts=$(gh api \
            -H "Accept: application/vnd.github+json"\
            -H "X-GitHub-Api-Version: 2022-11-28" \
             /repos/$REPO/actions/runs/$RUN_ID/artifacts)

            echo "$artifacts" | jq .

            artifact_id=$(echo "$artifacts" | jq -r --arg file_name "$FILE_NAME" '.artifacts[] | select(.name==$file_name) | .id')
            echo "artifact_id=$artifact_id" >> $GITHUB_ENV
            echo "Artifact ID: $artifact_id"

            artifact_size_in_bytes=$(echo "$artifacts" | jq -r --arg file_name "$FILE_NAME" '.artifacts[] | select(.name==$file_name) | .size_in_bytes')
            echo "artifact_size_in_bytes=$artifact_size_in_bytes" >> $GITHUB_ENV
            echo "Artifact SiZE: $artifact_size_in_bytes"

            artifact_url=https://github.com/$REPO/actions/runs/$RUN_ID/artifacts/$artifact_id
            echo "artifact_url=$artifact_url" >> $GITHUB_ENV
            echo "Artifact URL: $artifact_url"

      - name: Configurar chave SSH e Adicionar chave do host remoto ao known_hosts
        if: ${{ inputs.teste_input != true }}
        shell: bash
        run: |
          source /tmp/send_telegram_message.sh
          replicate
          msg "- name: Configurar chave SSH e Adicionar chave do host remoto ao known_hosts"
          #Configurar chave SSH e Adicionar chave do host remoto ao known_hosts
          mkdir -p /root/.ssh
          printf '%s\n' "${{ secrets.SSH_PRIVATE_KEY }}" > /root/.ssh/id_rsa
          chmod 700 /root/.ssh
          chmod 600 /root/.ssh/id_rsa

          msg "Testar chave se v√°lida:"
          ssh-keygen -l -f /root/.ssh/id_rsa

          # Adiciona o host aos conhecidos para n√£o travar
          ssh-keyscan -p 65002 -H ${{ secrets.SERVER_HOST }} >> /root/.ssh/known_hosts
          ssh-keyscan -p 65002 -H ${{ secrets.SERVER_HOST }} >> /root/.ssh/known_hosts2
          replicate

      - name: Enviar arquivo ISO para o servidor via SCP com porta customizada
        if: ${{ inputs.teste_input != true }}
        shell: bash
        run: |
          source /tmp/send_telegram_message.sh
          msg "- name: Enviar arquivo ISO para o servidor via SCP com porta customizada"
          ls -la "${{ env.ISO_PATH }}" --color=auto || true
          ls -la "${{ env.ISO_PATH }}.md5" --color=auto || true
          ls -la "${{ env.WORK_PATH }}/${{ env.ISO_BASENAME }}" || true

          # Envia a ISO e o MD5 usando os caminhos absolutos confirmados
          # SCP cir√∫rgico:
          # 1. Usa o curinga (*) para pegar tanto a ISO √∫nica quanto partes .7z
          # 2. BatchMode=yes para n√£o travar pedindo senha
          #${{ env.WORK_PATH }}/${{ steps.prepare-iso.outputs.release }}* \
          #-o BatchMode=yes \
          scp -P ${{ secrets.SERVER_PORT }} \
              -v \
              -o StrictHostKeyChecking=no \
              -i /root/.ssh/id_rsa \
              ${{ env.ISO_FULLNAME }} \
              ${{ env.ISO_FULLNAME }}.md5 \
              ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }}:/home/${{ secrets.SERVER_USER }}/void/iso
          replicate

      - name: Telegram Alert Fail - Send a Telegram alert if the build fails
        if: failure()
        shell: bash
        run: |
          source /tmp/send_telegram_message.sh
          msg "- name: Telegram Alert Fail - Send a Telegram alert if the build fails"
          #link_action=https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}
          #MESSAGE="üö® <b>[step x/3] - Falha ao criar ISO:</b>
          #<b>Job      :</b> <code>#${GITHUB_RUN_NUMBER}</code>
          #<b>Job URL  :</b> <a href='https://github.com/${GITHUB_REPOSITORY}/actions/runs/${GITHUB_RUN_ID}'>${link_action}</a>
          #<b>Workflow :</b> <code>${{ github.workflow }}</code>
          #<b>Iso      :</b> <code>${{ github.event.action }}</code>
          #<b>URL erro :</b> <a href='https://github.com/${GITHUB_REPOSITORY}/actions/runs/${GITHUB_RUN_ID}'>${link_action}</a>"
          # Remove as tags HTML e exibe o resultado no terminal
          #echo -e "${green}$(sed 's/<[^>]*>//g' <<< "$MESSAGE")${reset}"
          # Envia a mensagem para o Telegram com formata√ß√£o HTML
          #curl -s -X POST "https://api.telegram.org/bot${TELEGRAM_VOIDBR_ISO_TOKEN_BOT}/sendMessage" \
          #  -d chat_id="${CHAT_ID}" \
          #  -d message_thread_id="${MESSAGE_THREAD_ID}" \
          #  -d text="${MESSAGE}" \
          #  -d parse_mode="HTML"

          MESSAGE="üö® <b>[step x/3] - Falha ao criar ISO:</b>"
          send_telegram_message "$MESSAGE"

      - name: Capturar hora de t√©rmino e calcular dura√ß√£o
        shell: bash
        run: |
          source /tmp/send_telegram_message.sh
          replicate
          msg "- name: Capturar hora de t√©rmino e calcular dura√ß√£o"
          sh_calc_duration_via_normal() {
            # Configura√ß√µes
            START_TIME="${{ env.START_TIME }}"
            START_TIMESTAMP="${{ env.START_TIMESTAMP }}"
            END_TIME=$(date +"%Y-%m-%d %H:%M:%S")
            END_TIMESTAMP=$(date +%s)

            # Calcula a dura√ß√£o em segundos, horas, minutos e segundos
            duration=$((END_TIMESTAMP - START_TIMESTAMP))
            hours=$((duration / 3600))
            minutes=$(( (duration % 3600) / 60 ))
            seconds=$((duration % 60))
          }

          sh_calc_duration_via_api() {
            # Endpoint da API
            API_URL="https://api.github.com/repos/${GITHUB_REPOSITORY}/actions/runs"

            # Fazendo a requisi√ß√£o para obter o √∫ltimo workflow run
            response=$(curl -s -H "Authorization: Bearer $GITHUB_TOKEN" \
                              -H "Accept: application/vnd.github+json" \
                              "$API_URL")

            # Extraindo os hor√°rios (created_at e updated_at) do √∫ltimo workflow
            created_at=$(echo "$response" | jq -r '.workflow_runs[0].created_at')
            updated_at=$(echo "$response" | jq -r '.workflow_runs[0].updated_at')

            # Verificando se os valores foram obtidos
            if [[ -z "$created_at" || -z "$updated_at" ]]; then
              echo "Erro: N√£o foi poss√≠vel obter os dados do workflow."
              exit 1
            fi

            # Convertendo hor√°rios para timestamps
            start_ts=$(date -d "$created_at" +%s)
            end_ts=$(date -d "$updated_at" +%s)

            START_TIME="$created_at"
            END_TIME="$updated_at"

            # Calculando a dura√ß√£o em segundos
            duration=$((end_ts - start_ts))

            # Convertendo para formato leg√≠vel (HH:MM:SS)
            hours=$((duration / 3600))
            minutes=$(((duration % 3600) / 60))
            seconds=$((duration % 60))

            # Exibindo o tempo total
            printf "Tempo total da execu√ß√£o: %02d:%02d:%02d\n" "$hours" "$minutes" "$seconds"
          }

          sh_calc_duration_via_normal
          #sh_calc_duration_via_api

          # Obt√©m o ID do run e o URL do artefato a partir das vari√°veis de ambiente
          RUN_ID="${{ github.run_id }}"
          link_action="${{ env.artifact_url }}"
          file_name="${{ steps.prepare-iso.outputs.release_name }}"

          # Converte o tamanho do artefato para um formato leg√≠vel
          if [[ -z "${artifact_size_in_bytes}" ]]; then
            artifact_size_in_bytes=$(stat -c%s "${{ env.ISO_FULLNAME }}")
          fi
          iso_size=$(numfmt --to=iec --suffix=B "${artifact_size_in_bytes}") || true

          # Prepara a mensagem
          #link_action=https://github.com/${GITHUB_REPOSITORY}/actions/runs/${GITHUB_RUN_ID}
          #MESSAGE="‚è≥ <b>[step 3/3] - Finalizado em:</b> <code>${hours}h ${minutes}m ${seconds}s</code>
          #<b>Job      :</b> <code>#${GITHUB_RUN_NUMBER}</code>
          #<b>Job URL  :</b> <a href='https://github.com/${GITHUB_REPOSITORY}/actions/runs/${GITHUB_RUN_ID}'>${link_action}</a>
          #<b>Workflow :</b> <code>${{ github.workflow }}</code>
          #<b>Inicio   :</b> <code>${START_TIME}</code>
          #<b>Fim      :</b> <code>${END_TIME}</code>
          #<b>Nome ISO :</b> <code>${ISO_BASENAME}</code>
          #<b>Tam ISO  :</b> <code>${iso_size}</code>
          #<b>Download :</b> <a href='${{ env.artifact_url }}'>${file_name}.zip</a>"
          # Remove as tags HTML e exibe o resultado no terminal
          #echo -e "${green}$(sed 's/<[^>]*>//g' <<< "$MESSAGE")${reset}"
          # Envia a mensagem para o Telegram com formata√ß√£o HTML
          #curl -s -X POST "https://api.telegram.org/bot${TELEGRAM_VOIDBR_ISO_TOKEN_BOT}/sendMessage" \
          #  -d chat_id="${CHAT_ID}" \
          #  -d message_thread_id="${MESSAGE_THREAD_ID}" \
          #  -d text="${MESSAGE}" \
          #  -d parse_mode="HTML"

          MESSAGE="‚è≥ <b>[step 3/3] - Finalizado em:</b> <code>${hours}h ${minutes}m ${seconds}s</code>"
          send_telegram_message "$MESSAGE"
          replicate
