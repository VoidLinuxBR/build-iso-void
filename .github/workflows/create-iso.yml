name: ðŸ’¿ Build ISO ISO VoidLinux

# Gatilhos para o workflow
on:
  #  push:
  #    branches:
  #      - main
  repository_dispatch: # aguarda um evento externo para iniciar o workflow (Ãºtil para automaÃ§Ãµes externas que acionam o GitHub Actions).
    types:
      - "ISO-*"
  workflow_dispatch: # Permite a execuÃ§Ã£o manual do workflow via interface do GitHub, e vocÃª definiu inputs como name, edition, e tmate
    inputs:
      teste_input:
        type: boolean
        description: "Enable only test"
        required: false
        default: false
      vol_id:
        type: string
        description: "Nome do VOLUME da ISO"
        required: true
        default: "VOID_LIVE"
      edition:
        type: choice
        description: "Edition"
        options:
          - base
          - xfce
          - awesome
          - enlightnment
          - fluxbox
          - gnome
          - kde
          - all
        default: "xfce"
      tmate:
        type: boolean
        description: "Enable debugging with tmate"
        required: false
        default: false
      release_tag:
        type: string
        description: "Release tag for the ISO"
        required: false

  schedule:
    #- cron: "0 6 * * *" # Roda todo dia Ã s 06:00 UTC
    - cron: "0 18 * * 5" # Roda toda sexta-feira Ã s 18:00 UTC

env:
  TELEGRAM_TOKEN: "${{ secrets.TOKEN_BOT }}"
  #GITHUB_TOKEN: "${{ secrets.TOKEN_RELEASE }}"
  GITHUB_TOKEN: "${{ secrets.GITHUB_TOKEN }}"
  CHAT_ID: "${{ secrets.CHAT_ID }}"
  started_by_user: "${{ github.actor }}"
  triggered_by_user: "${{ github.triggering_actor }}"
  repo_path: "${{ secrets.PKGBUILD_DIR }}"
  #iso_distroname: "${{ github.event.client_payload.distroname || inputs.distroname || 'chililinux' }}"
  #iso_manjaro_branch: "${{ github.event.client_payload.manjaro_branch || inputs.manjaro_branch}}"
  #iso_biglinux_branch: "${{ github.event.client_payload.biglinux_branch || inputs.biglinux_branch}}"
  #iso_bigcommunity_branch: "${{ github.event.client_payload.community_branch || inputs.community_branch}}"
  #iso_chililinux_branch: "${{ github.event.client_payload.chililinux_branch || inputs.chililinux_branch}}"
  #iso_build_dir: "${{ github.event.client_payload.build_dir || inputs.build_dir}}"
  iso_edition: "${{ github.event.client_payload.edition || inputs.edition}}"
  iso_release_tag: "${{ github.event.client_payload.release_tag || inputs.release_tag }}"
  #iso_kernel: "${{ github.event.client_payload.kernel || inputs.kernel }}"
  iso_basename: "void-live-${iso_edition}-x86_64_${iso_release_tag}"

# Jobs do workflow
jobs:
  # Job para obter a hora atual
  setup:
    runs-on: ubuntu-latest
    outputs:
      time: ${{ steps.time.outputs.time }} # SaÃ­da do job
      REPOSITORY_NAME: ${{ steps.get-repo-name.outputs.repo_name }}
    steps:
      - name: Obter a hora atual
        id: time
        run: |
          #Obter a hora atual
          #echo "::set-output name=time::$(date +'%Y.%m.%d-%H%M')"
          echo "time=$(date +'%Y.%m.%d-%H%M')" >> $GITHUB_OUTPUT

      - name: Capturar hora de inÃ­cio do workflow
        id: start-time
        shell: bash
        run: |
          START_TIME=$(date +"%Y-%m-%d %H:%M:%S")  # Hora completa
          START_TIMESTAMP=$(date +%s)  # Timestamp em segundos
          echo "InÃ­cio do Workflow: $START_TIME"
          echo "START_TIME=$START_TIME"             >> $GITHUB_ENV
          echo "START_TIMESTAMP=$START_TIMESTAMP"   >> $GITHUB_ENV
          echo "START_TIME='$START_TIME'"           >> shared_file.txt
          echo "START_TIMESTAMP='$START_TIMESTAMP'" >> shared_file.txt

      - name: Install dependencies on HOST
        shell: bash
        run: |
          #Install dependencies on HOST
          #sudo apt-get update
          sudo apt-get autoremove
          sudo apt-get install -y inetutils-tools

      - name: Set up volume directory on HOST
        shell: bash
        run: |
          #Set up volume directory on HOST
          sudo mkdir -p /mnt/var_lib_manjaro_tools_buildiso
          sudo mkdir -p /mnt/var_cache_manjaro_tools_iso
          sudo mkdir -p /mnt/lfs

      - name: Enviar notificaÃ§Ã£o para o Telegram
        shell: bash
        run: |
          #Enviar notificaÃ§Ã£o para o Telegram
          echo "ISO_BRANCH='$iso_branch'" >> GITHUB_ENV
          echo "ISO_BRANCH='$iso_branch'" >> shared_file.txt
          link_action=https://github.com/${GITHUB_REPOSITORY}/actions/runs/${GITHUB_RUN_ID}

          MESSAGE="ðŸš€ <b>[step 1/3] build-iso-void - INICIANDO WORKFLOW</b>
          <b>Job:</b> <code>#${GITHUB_RUN_NUMBER}</code>
          <b>Job URL:</b> <a href='https://github.com/${GITHUB_REPOSITORY}/actions/runs/${GITHUB_RUN_ID}'>${link_action}</a>
          <b>Workflow:</b> <code>build-iso-void/create-iso.yml</code>
          <b>Iniciado/Triggered:</b> <code>${started_by_user}/${triggered_by_user}</code>
          <b>Inicio:</b> <code>${{ env.START_TIME }}</code>
          <b>Distroname:</b> <code>${iso_distroname}</code>
          <b>Iso Profile:</b> <code>${{ github.event.client_payload.iso_profiles_repo || inputs.iso_profiles_repo }}</code>
          <b>Edition:</b> <code>${iso_edition}</code>
          <b>Build dir:</b> <code>${iso_build_dir}</code>
          <b>Release:</b> <code>${iso_release_tag}</code>
          <b>Kernel:</b> <code>${iso_kernel}</code>
          <b>ISO Name:</b> <code>${iso_basename}</code>"
          # Remove as tags HTML e exibe o resultado no terminal
          echo -e "${green}$(sed 's/<[^>]*>//g' <<< "$MESSAGE")${reset}"
          # Envia a mensagem original com HTML para o Telegram
          curl -s -X POST "https://api.telegram.org/bot${TELEGRAM_TOKEN}/sendMessage" \
            -d chat_id="${CHAT_ID}" \
            -d text="${MESSAGE}" \
            -d parse_mode="HTML"

      #      - name: Cria um arquivo de variaveis para compartilhar entre jobs
      #        shell: bash
      #        run: |
      #          #Cria um arquivo de variaveis para compartilhar entre jobs
      #          echo "START_TIME='$START_TIME'"           >> shared_file.txt
      #          echo "START_TIMESTAMP='$START_TIMESTAMP'" >> shared_file.txt
      #          echo "ISO_BRANCH='$iso_branch'"           >> shared_file.txt

      - name: Obter nome do repositÃ³rio
        id: get-repo-name
        run: |
          #Obter nome do repositÃ³rio
          #echo "::set-output name=repo_name::$(basename $GITHUB_REPOSITORY)"
          echo "repo_name=$(basename $GITHUB_REPOSITORY)" >> $GITHUB_OUTPUT

      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: shared-file
          path: shared_file.txt

  build:
    name: Build ${{ github.event.client_payload.edition || github.event.inputs.edition || 'xfce' }}
    runs-on: ubuntu-latest
    needs: [setup] # Depende do job get-time para obter a hora atual e do job set-repo-name para obter o nome do repositÃ³rio
    env:
      REPO_NAME: ${{ needs.set-repo-name.outputs.REPOSITORY_NAME }} # Acesso Ã  variÃ¡vel de ambiente definida no job anterior
    container:
      image: vcatafesta/voidlinux-docker:latest
      options: --privileged
      volumes:
        - /mnt/lfs:/mnt/lfs

    steps:
      - name: Set up volume directory on HOST
        run: |
          #Set up volume directory on HOST
          mkdir -p /mnt/lfs

      - name: Install Required Packages and Libraries
        run: |
          #Install Required Packages and Libraries
          #{
          #echo 'repository=https://repo-fastly.voidlinux.org/current'
          #echo 'repository=https://repo-fastly.voidlinux.org/current/nonfree'
          #echo 'repository=https://repo-fastly.voidlinux.org/current/multilib'
          #echo 'repository=https://repo-fastly.voidlinux.org/current/multilib/nonfree'
          #echo 'repository=https://chililinux.com/void/current'
          #} > /etc/xbps.d/00-repository-main.conf

          xbps-install -Syu -ff \
            xbps \
            xtools \
            bash \
            sudo \
            openssh \
            tmate \
            xz \
            zip \
            kmod \
            ncurses \
            which \
            vpm \
            libstdc++ \
            vim \
            nano \
            curl \
            git \
            bash \
            tree \
            duf \
            gettext \
            rsync \
            util-linux \
            coreutils \
            sed \
            grep \
            btrfs-progs \
            e2fsprogs \
            exfatprogs \
            dosfstools \
            xfsprogs

      - name: Create user builduser in container
        run: |
          #Create user builduser in container
          useradd -m -G wheel,audio,video,cdrom,optical,kvm,xbuilder builduser

      - name: Display the current user in container
        run: |
          #Display the current user in container
          echo "#########################################"
          echo "Current container is: $(hostname)"
          echo "Current user is: $(whoami)"
          echo "Current user ID is: $(id -u)"
          echo "Current user details:"
          id
          echo "#########################################"
          df -hT
          echo "#########################################"
          ls -la /mnt
          echo "#########################################"

      - name: Initial Debug
        run: |
          #Initial Debug
          echo "Workflow started"
          echo "Event Name: ${{ github.event_name }}"
          echo "Event Action: ${{ github.event.action }}"

      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Start Building ISO
        if: ${{ inputs.teste_input != true }}
        uses: ./
        id: build
        with:
          vol_id: ${{ github.event.client_payload.vol_id || inputs.vol_id }}
          edition: ${{ github.event.client_payload.edition || inputs.edition }}
          release_tag: ${{ github.event.client_payload.release_tag || inputs.release_tag }}
          # DepuraÃ§Ã£o
          tmate: ${{ github.event.client_payload.tmate || 'false' }}
          # Tokens e segredos
          github_token: ${{ secrets.ORGANIZATION_TOKEN }}

      - name: Calculate MD5 Hash of files
        if: ${{ inputs.teste_input != true }}
        shell: bash
        run: |
          #Calculate MD5 Hash of files
          pushd "${{ env.WORK_PATH }}" || true
          echo "Calculating MD5 hash for: ${{ env.ISO_BASENAME }} file..."
          echo "ISO_BASENAME is: '${{ env.ISO_BASENAME }}'"
          if [[ -f "${{ env.ISO_BASENAME }}" ]]; then
            md5sum "${{ env.ISO_BASENAME }}" > "${{ env.ISO_BASENAME }}.md5"
            echo "MD5 '$ISO_BASENAME.md5' hash calculated and saved:"
            cat "${{ env.ISO_BASENAME }}.md5"
          else
            echo "ERRO: ${{ env.ISO_BASENAME }} file not found at ${{ env.WORK_PATH }}"
            exit 1
          fi
          popd || true

      - name: Prepare ISO file for release
        if: ${{ inputs.teste_input != true }}
        id: prepare-iso
        shell: bash
        run: |
          #Prepare ISO file for release
          pushd "${{ env.WORK_PATH }}" || true
          ls -lha
          release=${{ env.ISO_BASENAME }} # Apenas obtÃ©m o nome do arquivo com extensÃ£o
          release="${release%.iso}"
          echo "release_name=${release}" >> $GITHUB_ENV
          if zip \
              --junk-paths \
              --store \
              -s 2000m \
              ${release}.zip \
              ${{ env.ISO_FULLNAME }} \
              ${{ env.ISO_FULLNAME }}.md5; then
            echo "ISO_FULLNAME=${{ env.WORK_PATH }}/${release}.iso" >> "$GITHUB_ENV"
            echo "ISO_BASENAME=${release}.iso"                      >> "$GITHUB_ENV"
            echo "ZIP_BASENAME=${release}.zip"                      >> "$GITHUB_ENV"
            echo "${ISO_FULLNAME} prepared for release"
            ls -lha
          else
            echo "ERRO: No preparo do arquivo ISO para release"
            exit 1
          fi
          popd || true

      - name: Debug environment variables and List Files
        if: ${{ inputs.teste_input != true }}
        run: |
          #Debug environment variables and List Files
          echo "ISO_BASENAME=${{ env.ISO_BASENAME }}"
          echo "ISO_FULLNAME=${{ env.ISO_FULLNAME }}"
          echo "ISO Path from output=${{ steps.define-paths.outputs.iso_path }}"
          ls -lah "${{ env.WORK_PATH }}"

      - name: Verificar arquivo .iso
        if: ${{ inputs.teste_input != true }}
        run: |
          #Verificar arquivo .iso
          ls -lah --color=auto ${{ env.ISO_FULLNAME }} # Verifique se o arquivo .iso foi gerado corretamente

      - name: Upload FILES as artifact
        if: ${{ inputs.teste_input != true }}
        uses: actions/upload-artifact@v3
        env:
          GITHUB_TOKEN: ${{ secrets.ORGANIZATION_TOKEN }}
        with:
          name: ${{ env.ISO_BASENAME }}
          path: |
            ${{ env.ISO_FULLNAME }}
            ${{ env.ISO_FULLNAME }}
            ${{ env.ISO_FULLNAME }}.md5
          if-no-files-found: warn
          include-hidden-files: false

      - name: Criar release iso
        if: ${{ inputs.teste_input != true }}
        id: create_release
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.ORGANIZATION_TOKEN }}
        with:
          tag_name: ${{ env.ISO_TAG_NAME }}
          release_name: Release ${{ env.ISO_TAG_NAME }}
          body: |
            - **Data e Hora        :** ${{ needs.get-time.outputs.time }}
            - **Arquivo ISO        :** ${{ env.ISO_BASENAME }}
            - **Arquivo MD5        :** ${{ env.ISO_FULLNAME }}.md5
            - **Nome do RepositÃ³rio:** ${{ env.REPO_NAME }}
          draft: false
          prerelease: false

      - name: Configurar chave SSH e Adicionar chave do host remoto ao known_hosts
        if: ${{ inputs.teste_input != true }}
        run: |
          #Configurar chave SSH e Adicionar chave do host remoto ao known_hosts
          mkdir -p /root/.ssh
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > /root/.ssh/id_rsa
          chmod 600 /root/.ssh/id_rsa
          ssh-keyscan -p 65002 -H ${{ secrets.SERVER_HOST }} >> /root/.ssh/known_hosts
          ssh-keyscan -p 65002 -H ${{ secrets.SERVER_HOST }} >> /root/.ssh/known_hosts2

      - name: Enviar arquivo ISO para o servidor via SCP com porta customizada
        if: ${{ inputs.teste_input != true }}
        run: |
          #Enviar arquivo ISO para o servidor via SCP com porta customizada
          scp -P 65002 \
              -v \
              -o StrictHostKeyChecking=no \
              -i /root/.ssh/id_rsa \
              ${{ env.ISO_FULLNAME }} \
              ${{ env.ISO_FULLNAME }}.md5 \
              ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }}:/home/${{ secrets.SERVER_USER }}/void/iso

      - name: Fazer upload do arquivo .zip no release
        if: ${{ inputs.teste_input != true }}
        id: upload-release-asset
        uses: actions/upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ secrets.ORGANIZATION_TOKEN }}
        with:
          upload_url: ${{ steps.create_release.outputs.upload_url }} # URL gerada no passo da criaÃ§Ã£o da release
          asset_path: ${{ env.ZIP_BASENAME }} # Caminho do arquivo .iso
          asset_name: ${{ env.ZIP_BASENAME }}.zip
          asset_content_type: application/zip # Tipo correto para arquivos .z
